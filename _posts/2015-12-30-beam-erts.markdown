---
layout: post
title:  "BEAM & ERTS"
date:   2015-12-30 16:45:00 +0800
categories: erlang
---

#**BEAM是什么？**
BEAM全称是Bogdan/Björn's Erlang Abstract Machine

#**ERTS是什么？**
ETRS全称是Erlang Run-Time System

#**erlang的进程是什么？**
erlang的进程实际上就是一堆内存里的数据，他是虚拟的概念。实际工作都是由一个叫scheduler的线程去处理。

#**scheduler是什么？**
scheduler是整个虚拟机实际工作的线程，他有4个队列，分别为'max', 'high', 'normal', 'low'，这个4个队列里放的就是erlang的进程，队列里的erlang进程按顺序被scheduler运行。这4个队列是有优先级的，字面上的意思max>high>normal=low，当高优先级的队列中有进程的时候，优先运行高优先级队列中的erlang进程。

#**smp是什么？**
smp的目的是充分利用当前计算机的多核特性，给每个核绑定一个scheduler，这样达到并行处理的目的，提高了beam的处理能力。现在的beam都是默认启动smp的，所以默认就有多个scheduler，否则就只有一个scheduler线程。

#**公平调度和抢占式调度是什么？**
每个erlang进程都有个reduction counter（进程创建的时候赋值2000），当scheduler执行完一次完整的erlang函数调用后，该erlang进程的reduction counter减一，当reduction counter归零，这个erlang进程重新会本队列的尾部，scheduler运行队列中下一个erlang进程，这样才能保证每个erlang的进程都能有机会被scheduler执行，而不会因为某个erlang进程一直在运行而阻塞整个scheduler的执行队列，这就是抢占式调度或者公平调度。

#**scheduler的任务迁移是什么？**
在smp模式下，多个scheduler有多个erlang进程的执行队列，BEAM会对所有的队列做统计求出个队列长度平均值，并根据现有的情况作出一个迁移计划来，把队列长度高于平均值的scheduler的队列里的待执行erlang进程迁移到队列小于平均值的scheduler的队列中，最终维护大体平均的执行队列。

#**什么是async threads？**
async threads实际上是处理IO的一些事。

#**什么是allocator？**
allocator是ERTS自己的内存分配器，每个调度器线程都有自己的一整套allocator，包括

* **temp_alloc**  
    用于分配临时数据的内存分配器
* **eheap_alloc**  
    用于分配Erlang堆数据的内存分配器，例如Erlang进程的独占堆。
* **binary_alloc**  
    用于分配Erlang二进制的内存分配器。
* **ets_alloc**  
    用于分配ETS数据的内存分配器。
* **driver_alloc**  
    用于分配驱动（driver）的内存分配器。
* **sl_alloc**  
    用于分配短生存周期的内存区块（memory blocks）的内存分配器。
* **ll_alloc**  
    用于分配长生存周期的内存区块的内存分配器，例如Erlang的代码。
* **fix_alloc**  
    用于分配被频繁调用的固定长度的数据类型的内存分配器。
* **std_alloc**  
    用于分配大多数没被其他类型的内存分配器分配的数据的内存分配器。
* **sys_alloc**  
    用于通过malloc实现从OS里获取内存的内存分配器。
* **mseg_alloc**  
    一个内存片段分配器。mseg_alloc被用来给其他的Erlang分配器分配内存片段，并且仅仅在操作系统支持mmap系统调用的时候才能有效使用。这些分配给其他内存分配器的内存片段在被释放的时候不会立即销毁并还给操作系统，而是作为片段缓存一段时间。当其他内存分配器调用mseg_alloc来获取内存片段的时候，优先使用缓存的内存片段，而不是向操作系统创建新的内存片段。这样做是为了尽量少的做操作系统调用。

之所以要定义这么多不同的alloctor是为了让不同的数绝结构分别放在不同的内存区域中，期望有效的减少内存碎片的产生。

#**什么是carrier？**
由于erlang语言有不同的数据类型，例如binary，list，atom，port，process等等。不同的数据类型需要不同的数据结构在内存中存储，实际存储数据的东西叫区块（block）。而ERTS的allocator不能直接操作区块，而是操作叫载体（carrier）的东西。载体分为单块载体和多块载体，单块载体内部只存储一个区块，多块载体内部存储多个区块。