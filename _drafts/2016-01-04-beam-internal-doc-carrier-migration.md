---
layout: post
title:  "Beam Internal Doc -- Carrier Migration!"
author: "肖铁(Kevin)"
categories: erlang
---

#载体迁移（Carrier Migration）
  
ERTS的内存分配器把原始的内存区块当作为2种不同的内存块来管理。这种意义上的内存块叫做载体（carriers）。单块载体（Singleblock carriers）只包含一个大内存区块，多块载体（Multiblock carriers）包含多个内存区块。在unix系统中载体的内存是有mmap()函数分配的，但这并不重要。一个内存分配器实例通常管理若干个单块载体和多块载体。  

##问题  

当一个载体为空，例如一个空的单块载体，它会被释放掉。但是作为多块载体，他内部的内存区块有可能部分是空的，部分是有数据的，如果内存负载降低，由于大量的低利用率的多块载体的存在，内存分配器实例可能被卡住。内存使用经过一个高峰后，可以预见的是，由于数据分布在多个多块载体中，导致内存不能被全部回收释放。没有被完全使用的多块载体在内存负载再次增高的时候，空闲的部分会被重用。然而，既然每个调度器线程都有自己的一套内存分配器实例，而内存负载和CPU负载也没有必然的联系，就有可能出现这样一种状况，某些内存分配器实例有一大堆地低利用率的多块载体，另外的内存分配器实例则需要创建新的多块载体。这时，系统的多块载体需求量增加的同时实际内存需求量反而是下降的，这一切对erlang的开发人员来说都是不希望出现的。  

##解决方案：  
 
为了防止这种情况的出现，我们引入了一种新的机制--同种内存分配器实例之间的多块载体迁移。（我的理解：首先不同种的内存分配器不可以做载体迁移，为啥？因为每个种类的载体所占用的空间大小不一样，数据结构也不一样。每个内存分配器其实就是C里的结构体，要用的时候需要按照自己结构体的属性来分配大小，之所以有这么多种类的内存分配器就是因为需要存储不同的结构体。同种的内存分配器其实结构体是一样的，所以他们创建的载体也是一样的，所以可以做迁移）  

###空闲块的管理  

为了让一个载体从一个内存分配器实例删除并添加到另外一个内存分配器实例上，我们需要在内存分配器实例之间移动载体内空闲的区块的引用。内存分配器里具体存储“指向这个内存分配器所管理的内存块”的**数据结构**经常都指向的是同一个载体的不同位置。举个例子，当使用address order bestfit作为内存分配策略时，这个**数据结构**是一个跨越所有这个内存分配器所管理的载体的二叉搜索树。在具体的某个载体中的空闲内存块可以被潜在的每个载体引用并管理，并且这种类似的引用可以有很大的数量。也就是说，从二叉搜索树中除去“这样的载体中的空闲块”的工作将是巨大的。有一种解决这种问题的方法可能就是别迁移“这种含有很多空闲块的载体”，但是这会妨碍我们迁移“有潜在迁移需要的载体”，导致阻止我们解决通过块迁移能解决的大量内存碎片的问题。

通过从每个载体中使用一个数据结构体的方式，一个内存分配器实例层面的载体的数据结构体
这个被需要的工作 为了删除和添加载体可以保持在最小 为了保证载体是最小这个工作
