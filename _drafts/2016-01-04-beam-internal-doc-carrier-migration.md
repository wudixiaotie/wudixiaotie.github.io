---
layout: post
title:  "Beam Internal Doc -- Carrier Migration!"
categories: erlang
---

#载体迁移（Carrier Migration）
  
ERTS的内存分配器把原始的内存区块当作为2种不同的内存块来管理。这种意义上的内存块叫做载体（carriers）。单块载体（Singleblock carriers）只包含一个大内存区块，多块载体（Multiblock carriers）包含多个内存区块。在unix系统中载体的内存是有mmap()函数分配的，但这并不重要。一个内存分配器实例通常管理若干个单块载体和多块载体。  

##问题  

当一个载体为空，例如一个空的单块载体，它会被释放掉。但是作为多块载体，他内部的内存区块有可能部分是空的，部分是有数据的，如果内存负载降低，由于大量的低利用率的多块载体的存在，内存分配器实例可能被卡住。内存使用经过一个高峰后，可以预见的是，由于数据分布在多个多块载体中，导致内存不能被全部回收释放。没有被完全使用的多块载体在内存负载再次增高的时候，空闲的部分会被重用。然而，既然每个调度器线程都有自己的一套内存分配器实例，而内存负载和CPU负载也没有必然的联系，就有可能出现这样一种状况，某些内存分配器实例有一大堆地低利用率的多块载体，另外的内存分配器实例则需要创建新的多块载体。这时，系统的多块载体需求量增加的同时实际内存需求量反而是下降的，这一切对erlang的开发人员来说都是不希望出现的。  

##解决方案：  
 
为了防止这种情况的出现，我们引入了一种新的机制--同种内存分配器实例之间的多块载体迁移。  

###空闲块的管理  

为了让一个载体从一个内存分配器实例删除并添加到另外一个内存分配器实例上，我们需要在两个内存分配器实例之间移动载体内空闲的区块的引用。
