---
layout: post
title:  "Beam Internal Doc -- ProcessManagementOptimizations!"
author: "肖铁(Kevin)"
categories: erlang
---

##Problems

在早期版本的运行时系统中，对于SMP的支持都是依靠锁来在多线程时保护数据的访问。在某些情况下，这不是问题，但在某些情况下，它确实是。加锁使得代码变得复杂，要确保所有需要锁的地方都加了锁，还要确保所有的锁都在一种次序之下被获取而不会产生死锁。按照正确的次序获取锁也经常会影响锁的释放，迫使线程去读取已经读取过的数据。更有利于bug的产生。为了尽可能的提高并行执行的能力而把锁的粒度做细，这导致代码的复杂度进一步提高。在程序运行的时候迫使线程获取锁的操作通常会导致重度锁竞争，从而使的可扩展性反而下降。

运行时系统内部的进程管理会受困于这些问题。当更改一个进程的状态从waiting到runnable时，这个进程就需要被加个锁。当把一个进程插入到运行队列的时候还是需要加一个锁来保证运行队列此时是被锁的。当在两个运行队列进行任务迁移的时候，被迁移的进程还有两个运行队列都要加锁。

最后一个例子在系统正常运行的时候是挺普遍的情况。举个例子，当一个调度器线程干完了自己队列里的所有任务，他就会从别的调度器线程的运行队列里偷任务来给自己做。当这个调度器线程查找目标的时候就会对涉及到的运行队列做很多锁操作，而当它真正开始做任务迁移的时候，又会对自己和对方的运行队列还有被迁移的进程加锁。而当一个调度器的运行队列空了的时候，一般其他的调度器的运行队列也空了，这导致大家都去搜索目标所以产生了大量的锁竞争。

##Solution

###Process

为了避免这种情况的发生，我们希望在对一个进程做些基本操作的时候不需要对这个进程加锁。一些基本的操作例如，在不同的运行队列之间迁移进程，检测我们是否需要把一个进程插入到某个运行队列，检测一个进程是否活着。

所有基本操作需要的信息都包含在进程的结构体中，这个结构体被进程status锁所保护，这些信息是分布在一系列不同的field中。这些被使用的field通常是状态field，用来存储少数不同状态。通过对这些信息的重新排序，我们很容易把这些信息存储在32位宽度的field中（只有12位被占用）。通过移动这些信息我们可以从进程的结构体中删除5个32位宽的field和1个指针field。这一举措也使我们能够轻松地阅读和使用原子内存操作改变状态。

###Run Queue

为使我们在对进程做基本操作的时候不需要加锁，我们最需要知道的是目标的运行队列里是否允许进程进行enqueue操作。这涉及到读取实际负载和负载均衡的信息的能力。

负载均衡功能会每隔固定的时间间隔触发一次。负载均衡会努力拉平系统中各个运行队列的长度。当负载均衡被触发的时候，关于每个运行队列的信息被收集在了一起，迁移路径和运行队列长度限制都被设定好。迁移路径和运行队列长度的限制被设定好后直到下次负载均衡之后才会被更改。每个运行队列里最重要的信息是自上次负载均衡后运行队列的最大长度。所有这些信息都被提前存储在了运行队列中。

当一个进程的状态变成可运行的时候，举个例子消息的接收，我们需要决定对哪个运行队列进行enqueue操作。前先这个操作可能导致进程所在的运行队列被锁住，直到进程的状态信息被改变完成。根据负载的情况，我们有时候不得不为另一个运行队列加锁，从而根据这个队列的信息来决定是否把任务迁移到这个队列中。


