---
layout: post
title:  "Beam Internal Doc -- ProcessManagementOptimizations!"
author: "肖铁(Kevin)"
categories: erlang
---

##Problems

在早期版本的运行时系统中，对于SMP的支持都是依靠锁来在多线程时保护数据的访问。在某些情况下，这不是问题，但在某些情况下，它确实是。加锁使得代码变得复杂，要确保所有需要锁的地方都加了锁，还要确保所有的锁都在一种次序之下被获取而不会产生死锁。按照正确的次序获取锁也经常会影响锁的释放，迫使线程去读取已经读取过的数据。更有利于bug的产生。为了尽可能的提高并行执行的能力而把锁的粒度做细，这导致代码的复杂度进一步提高。在程序运行的时候迫使线程获取锁的操作通常会导致重度锁竞争，从而使的可扩展性反而下降。

运行时系统内部的进程管理会受困于这些问题。当更改一个进程的状态从waiting到runnable时，这个进程就需要被加个锁。当把一个进程插入到运行队列的时候还是需要加一个锁来保证运行队列此时是被锁的。当在两个运行队列进行任务迁移的时候，被迁移的进程还有两个运行队列都要加锁。

最后一个例子在系统正常运行的时候是挺普遍的情况。举个例子，当一个调度器线程干完了自己队列里的所有任务，他就会从别的调度器线程的运行队列里偷任务来给自己做。当这个调度器线程查找目标的时候就会对涉及到的运行队列做很多锁操作，而当它真正开始做任务迁移的时候，又会对自己和对方的运行队列还有被迁移的进程加锁。而当一个调度器的运行队列空了的时候，一般其他的调度器的运行队列也空了，这导致大家都去搜索目标所以产生了大量的锁竞争。

##Solution

###Process

为了避免这种情况的发生，我们希望在对一个进程做些基本操作的时候不需要对这个进程加锁。一些基本的操作例如，在不同的运行队列之间迁移进程，检测我们是否需要把一个进程插入到某个运行队列，检测一个进程是否活着。

所有基本操作需要的信息都包含在进程的结构体中，这个结构体被进程status锁所保护，这些信息是分布在这个结构体的一系列不同的field中。
