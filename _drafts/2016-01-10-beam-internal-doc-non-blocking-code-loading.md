---
layout: post
title:  "Beam Internal Doc -- Non-Blocking Code Loading"
author: "肖铁(Kevin)"
categories: erlang
---

##介绍

在OTP R16之前，当虚拟机运行在单线程模式并且正在载入代码时候整个虚拟机会挂起，直到代码载入完成。这在虚拟机启动的时候不是个大问题，但当虚拟机在运行并且有部分负载的情况下，就有可能成为一个严重的问题。这个问题随着cpu核的数量增加，所耗费的时间也会因为等待所有调度器停止并挂起正在做的工作而增加。

在OTP R16版本，模块的载入不会阻塞虚拟机了。Erlang进程在整个载入过程中会继续不受干扰的执行。代码载入会有单独的Erlang进程去处理，就像其他普通的Erlang进程一样，被调度器调度。代码的载入完成后会对所有的进程可见，并且其一致性由原子级别的操作来保证。在SMP模式，非阻塞代码载入会提高载入或替换的实时性。

##载入阶段

模块的载入分为2个阶段：

1. 预备阶段  
	预备阶段包含读取BEAM文件和被载入代码的所有准备工作，这些工作都是为了载入能顺利完成，防止对正在运行的其他代码产生干扰。
2. 完成阶段  
	完成阶段是使被载入的代码能被其他正在运行的代码访问，并且老版本的代码不能被访问。

准备阶段被设计为可以让多个负责载入代码的进程准备不同的模块，但是完成阶段这些准备好的进程只能依次完成。第二个等待载入的进程想进入完成阶段，必须要在第一个进程完成后，否则等待。这只会阻塞住Erlang进程，而调度器在第二个进程等待的时候会调度其他的工作，不会被阻塞住。

这个并行准备载入的能力不是经常使用，因为大部分的代码都是由code_server进程按顺序的载入。

{% highlight erlang %}
erlang:prepare_loading(Module, Code) -> LoaderState
erlang:finish_loading([LoaderState])
{% endhighlight %}

原理是 prepare_loading 可以同时被多个不同的模块调用，并返回一个包含所有准备的模块的内部状态的“magic binary”。函数 finish_loading 可以接收这些内部状态的列表，然后由他完成剩下的所有工作。

最近我们用BIF erlang:load_module， 这个函数会依次调用上述两个函数。finish_loading函数的参数会是一个只有单个模块状态的列表，因为我们没有使用多模块载入特性。

##完成顺序

在整个虚拟机执行期间，代码可以通过一系列数据结构被访问。这些可以访问代码的数据结构有：

* 输出列表。一个包含所有输出函数的实体。
* 模块列表。一个包含所有载入模块的实体。
* "beam_catches"。识别指令的跳转目的地。
* "beam_ranges"。函数的代码地址和源文件中的行之间的映射。

这些数据结构中最产用的就是“输出列表”，这个列表在运行期间被每个外部函数用来获得被调用者的地址。由于性能的原因，我们想要访问所有这些结构没有任何线程同步的开销。早期这会被紧急中断来解决。当数据结构有变动的时候整个虚拟机都停掉，平时的话他们是只读的。

R16的解决方案是复制这些数据结构。我们有一套数据结构被正在执行的代码读取。当新代码被载入的时候，这套数据结构被复制了一份，并把新代码更新到这被复制的数据中，然后替换掉现有的数据。当前活动的数据集合由单独的原子变量（线程安全的无锁变量）the_active_code_index来识别。数据的替换是由一个原子级别打写操作来实现的。每当ERTS正在运行的代码要访问这些数据结构的时候，都要读取the_active_code_index的值，这意味着每次函数调用都要执行一次原子级别的读操作。这个原子读操作所损失的性能非常小，因为这个操作不需要任何内存屏障（内存的访问顺序不一定和代码的编写顺序一致，这叫内存乱序访问。这是为了提高程序运行时的性能，但多CPU多线程的时候有可能有数据不同步。内存屏障的作用就是保证内存屏障之前的内存访问操作必定先于其之后完成，保证程序的运行顺序）就能被执行。这个解决方案还可以有效的保证代码载入操作的事务特性。正在运行的代码永远不会看见载入到一半的新代码。

完成阶段由BIF erlang:finish_loading函数按如下的顺序执行：

1. 抓住专属的代码写权限（暂停进程直到我们拿到）。
2. 把所有的有效访问数据都复制一份。这个副本叫做待命区域并由全局原子变量the_staging_code_index标识。
3. 把待命区域的访问数据全部更新成新的准备好的模块。
4. 调度一个线程过程执行事件。使得未来的某个时间，所有的调度器已经获得并执行完一个完整的内存屏障。
5. 暂定载入进程。
6. 在线程过程执行之后，通过把原子变量the_staging_code_index的值赋给the_active_code_index来提交待命区域。
7. 释放掉代码写权限，来允许其他的进程集结待命新的代码。
8. 载入进程从erlang:finish_loading函数中返回。

##线程过程执行

在完成阶段的4-6步骤中，执行线程过程的时候，载入进程的等待是有必要的，是为了使进程在执行普通函数调用的时候能原子的读取the_active_code_index而不用耗费任何昂贵的内存屏障。
