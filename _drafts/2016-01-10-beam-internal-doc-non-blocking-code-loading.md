---
layout: post
title:  "Beam Internal Doc -- Non-Blocking Code Loading"
author: "肖铁(Kevin)"
categories: erlang
---

##介绍

在OTP R16之前，当虚拟机运行在单线程模式并且正在载入代码时候整个虚拟机会挂起，直到代码载入完成。这在虚拟机启动的时候不是个大问题，但当虚拟机在运行并且有部分负载的情况下，就有可能成为一个严重的问题。这个问题随着cpu核的数量增加，所耗费的时间也会因为等待所有调度器停止并挂起正在做的工作而增加。

在OTP R16版本，模块的载入不会阻塞虚拟机了。Erlang进程在整个载入过程中会继续不受干扰的执行。代码载入会有单独的Erlang进程去处理，就像其他普通的Erlang进程一样，被调度器调度。代码的载入完成后会对所有的进程可见，并且其一致性由原子级别的操作来保证。在SMP模式，非阻塞代码载入会提高载入或替换的实时性。

##载入阶段

模块的载入分为2个阶段：

1. 预备阶段  
	预备阶段包含读取BEAM文件和被载入代码的所有准备工作，这些工作都是为了载入能顺利完成，防止对正在运行的其他代码产生干扰。
2. 完成阶段  
	完成阶段是使被载入的代码能被其他正在运行的代码访问，并且老版本的代码不能被访问。

准备阶段被设计为可以让多个负责载入代码的进程准备不同的模块，但是完成阶段这些准备好的进程只能依次完成。第二个等待载入的进程想进入完成阶段，必须要在第一个进程完成后，否则等待。这只会阻塞住Erlang进程，而调度器在第二个进程等待的时候会调度其他的工作，不会被阻塞住。

这个并行准备载入的能力不是经常使用，因为大部分的代码都是由code_server进程按顺序的载入。

{% highlight erlang %}
erlang:prepare_loading(Module, Code) -> LoaderState
erlang:finish_loading([LoaderState])
{% endhighlight %}

原理是 prepare_loading 可以同时被多个不同的模块调用，并返回一个包含所有准备的模块的内部状态的“magic binary”。函数 finish_loading 可以接收这些内部状态的列表，然后由他完成剩下的所有工作。

最近我们用BIF erlang:load_module， 这个函数会依次调用上述两个函数。finish_loading函数的参数会是一个只有单个模块状态的列表，因为我们没有使用多模块载入特性。

##完成顺序

在整个虚拟机执行期间，代码可以通过一系列数据结构被访问。这些可以访问代码的数据结构有：

* 输出列表。一个包含所有输出函数的实体。
* 模块列表。一个包含所有载入模块的实体。
* "beam_catches"。识别指令的跳转目的地。
* "beam_ranges"。函数的代码地址和源文件中的行之间的映射。

这些数据结构中最产用的就是“输出列表”，这个列表在运行期间被每个外部函数用来获得被调用者的地址。由于性能的原因，我们想要访问所有这些结构没有任何线程同步的开销。早期这会被紧急中断来解决。当数据结构有变动的时候整个虚拟机都停掉，平时的话他们是只读的。

R16的解决方案是复制这些数据结构。我们有一套数据结构被正在执行的代码读取。当新代码被载入的时候，这套数据结构被赋值了一份，并把新代码更新到这被复制的数据中，然后替换掉现有的数据。
