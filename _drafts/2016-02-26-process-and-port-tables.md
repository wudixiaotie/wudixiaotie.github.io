---
layout: post
title:  "Beam Internal Doc -- Process and Port Tables!"
author: "肖铁(Kevin)"
categories: erlang
---

##Problems

进程表是进程标识到进程结构体指针的映射。进程结构体包含了很多进程相关的杂七杂八的信息，例如指向进程堆的指针，进程的消息队列等等。当erlang运行时系统需要操作一个进程的时候，它就会去进程表中通过进程标识查找进程结构体。其中一个例子就是在发送消息给某个进程的时候。

进程表有很长一段时间的结构其实是一组元素为指向进程结构体的指针的数组。由于运行时系统中的进程标识是28位整数，相对于指针来说它能更好的索引。28位数字被分为2组。比较不重要的那组用来索引数组。重要的那组只用于区分索引到同一个元素时的若干进程指针。只要使用2的幂来表示进程表的大小，我们就有了2^28个不重复的进程标识。

当第一个支持SMP的erlang运行时系统被实现的时候，进程表的结构没什么太大的变化，但是加了2种锁来保护。一个锁用来保护对整个进程表的修改，一个数组的锁用来保护进程表的不同部分。上述的锁策略没什么可细说的。但是需要提及的是，进程表受困于沉重的锁竞争带来的资源消耗，尤其是当有很多修改的时候，或者大量查找的时候。

为了能知道什么时候才能安全的释放一个之前使用的进程结构体，需要对这个结构体的修改进行引用计数。而这样做也有问题，由于会有很多的线程同时查找这个引用计数器，这样做也会导致存储引用计数器的缓存线的竞争。这是由于所有的修改都需要在涉及到的处理器之间通信。

端口表和进程表类似。主要的不同，至少在概念上，它是有端口标识映射到端口结构体。实现上都很相似，只是有一些不同。它有一个元素为结构体的数组，而不是元素为指针的数组。这个数组由一个全局锁保护着，而不是有两种不同类型的锁来保护。不过端口表还是受困于锁争带来的性能损失。

##Solution

进程表的最大问题是进程的使用频率远远高于端口的。最开始只有进程表才这样去实现，可是由于端口表和进程表非常相似而且也有同样的问题，所以后来进程表的实现方式推广到了端口表。为了表述方便，在以下的内容中，我就以进程表代表了进程和端口表，因为它们实在太相似了。

如果我们忽视锁争问题，最原始的解决方案是很优秀的。从进程标识到数组的索引的映射的速度是非常快的，这个方案是我们希望保留下来的。对这些表的巨大广大的操作是查询，所以对查询的优化是我们要做的。

##Lookup

进程的标识由一组位作为一个数组的索引似乎很难推翻。通过把指针数组替换成另外的一个数组，数组元素为指针大小的原子数据类型，一次查询会细分为如下：

1. 28位的数字映射到数组的索引。
2. 通过一个原子内存操作从数组中指定索引来读取指针。
	所有操作系统平台都提供原子内存操作，这是一个volatile类型（volatile的作用是： 作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值.）的读操作，防止编译器从寄存器里读这些值，强迫从内存里读取。
3. 根据使用情况，适当的加入内存屏障。
	常用的内存屏障是语义的屏障。在x86/x86_64架构中，这种映射到一个编译器屏障防止编译器对指令进行重排，但是从其他的硬件中，少量的硬件内存屏障是必须的。
	当与有锁的方式对比，当有大量的锁产生的时候至少会导致大量的内存屏障产生，如果不是全部，硬件架构（包括x86/x86_64），在取消这些锁的时候经常会导致有少量的内存屏障产生。

当从更高的角度看这个非常简单的方案的时候，你或许会疑问：为什么我们不在最开始的时候用这种方式来实现进程表呢？这些都可以算作指针的读操作。我们需要一些方式去了解在访问指针指向的内存时是否安全。一种方式是对进程结构体做引用计数。当查询进程结构体的时候它的引用计数会同时增加。一个锁一般为我们提供这种服务，也就是我们之前所用的途径。另一种途径是在进程表中引用计数和指针放在一起。这种途径的主要问题是对引用计数的修改。这样会使得做这些修改的时候需要在所有涉及到的处理器之间通信，因为这些处理器的缓存线中都包含有引用计数器。在我们使用“线程进度”机制后可以让我们知道什么时候可以安全的释放进程结构体，这使得上面提到的新的查找途径成为可能。在描述从表中删除数据时，我们会再次会到这。

使用新的查找途径我们就不能对内存进行任何修改了，可是修改对于进程表来说非常重要。查找的意思就是仅仅读取内存，现在的实现来说这么说是正确的并且重要的是扩展透明的。之前的实现中每次查询会修改2次包含引用计数器的缓存线，包含与之关联的锁的缓存线也被修改了2次。

###Modifications of the Table

对进程表进行轻量级的查询是最重要的特性，但是我们还是希望提高对进程表修改的性能。进程被创建的时候就会修改进程表，这时，一个新的指针被插入到进程表中。当一个进程被终结的时候也会修改进程表，对应的指针被从进程表中删除。

假设我们创建了几个进程，这些进程数量上比系统允许的最大的唯一进程标识数量少（不会去重用被终结的进程的标识符），通过对比进程的标识符总能知道进程的创建顺序。如果PidX的值大于PidY,并且这两个进程属于同一个节点，说明PidX是在PidY后创建的。然而并没有什么卵用，由于我们今天对唯一标识符的数量有限制（2^28），导致当我们创建了大量的进程后，就不能凭这个特性来判断创建的先后关系。但尽管如此，这个属性将始终被留在系统中。

如果我们有大量的唯一进程标识符的可用，那么扔掉或者修改上述的排序属性是很诱人的。这个排序属性可以基于调度器处理创建进程操作的先后。它有可以为每个调度器线程单独保留了很大范围的唯一标识符，这样就使得在创建唯一标识符的时候调度器间的通信会最小。今天的技术能实现的标识符的数量，离这个途径所需要的数量还差的远呢。

既然我们只能拥有一定数量的独立标识，我们需要小心使用避免浪费。如果之前使用的标识符被迅速的重用，被终结的进程所属的标识符会代表新创建的进程，然后混淆就会发生。之前使用的途径在避免浪费的方面做的很不错。使用一个同样途径的修改版本也可以让我们和原来一样保持排序属性。

####Insert

原始途径或多或少的要去查找数组的下一个空闲的索引或者插槽。搜索开始与最后一个被分配的插槽。如果我们到达了数组的结尾，我们增加一个“覆盖计数器”，并继续搜索。进程标识符是由什么组成的呢？最小标识索引和“覆盖计数器”的两组比特。每组比特的数量是在ERTS启动的时候确定，所以索引的最大值和最小标识索引恰好合适。

把这种方案修改成无锁的版本，我们也要用差不多同样的方式，但是有些重要的修改是为了在多调度器同时创建进程的时候避免不必要的竞争。由于多线程可能在同一时间从同一个起点去搜索下个空闲插槽，我们希望之后的插槽在不同的缓存线中。多调度器同时写新的指针到表里极有可能导致写道相邻的插槽中。如果相邻的插槽在同一个缓存线中，所有对这个缓存线的修改都要在所有相关的处理器之间通信，这将导致非常昂贵的消耗，可扩展性相当的低。把相邻的查早存储在不同的缓存线中，只有真正的冲突才会在涉及的处理器间通信，可以避免假共享。

缓存线一般比指针大8或16倍，所以每个插槽用一个缓存线存储一个指针是非常浪费空间的行为。每个缓存线可以存储一组固定数目的插槽。进程表的第一个插槽将会是第一个缓存线的第一个插槽，进程表的第二个插槽将会是第二个缓存线的第一个插槽，直到没有新的缓存线可用。这时下一个插槽我们放在第一个缓存线的第二个位置，每当我们完成一圈后，都依次将插槽的位置在缓存线中向后移一位。这种方式我们就可以保证每个相邻的插槽都在不同的缓存线中。

标识符到进程表索引的映射比之前的稍稍复杂一些。我们将用两个shift（位移），两个and（与），一个add（参见erl_ptab.h中的erts_ptab_data2pix()函数的实现），代替原来的一个shift和一个and。然而，在32位平台上对存储的信息进行查询优化我们仅需要一个shift和一个and操作。在64位平台上我们有足够的空间来存放28位的标识符和表的索引，也就是说我们仅需要读取表的索引。
